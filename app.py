# -*- coding: utf-8 -*-
"""03 Despliegue - Trabajo final.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dKDZTcJzi902nhq2ltx-HiMNVWdHoEy-
"""

#Importamos librerías básicas
import pandas as pd # manipulacion dataframes
import numpy as np  # matrices y vectores
import matplotlib.pyplot as plt #gráfica

#Cargamos el modelo
import pickle
filename = 'modelo.pkl'
modelNN,variables,min_max_scaler= pickle.load(open(filename, 'rb'))

#Cargamos los datos futuros
#data = pd.read_csv("cancer_datos_futuros.csv", sep=';')
#data.head()

#Se crea interfaz gráfica con streamlit para captura de los datos
 
import streamlit as st
 
st.title('Predicción para la clasifición de un tumor benigno o maligno')
 
radius_mean = st.slider('radius_mean', min_value=7.0, max_value=10.0, value=7.0, step=0.05)
texture_mean = st.slider('texture_mean', min_value=9.0, max_value=39.0, value=9.0, step=0.2)
smoothness_mean = st.slider('smoothness_mean', min_value=0.04, max_value=0.2, value=0.04, step=0.002)
compactness_mean = st.number_input('compactness_mean', value=0.015)
symmetry_mean = st.number_input('symmetry_mean', value=0.1)
fractal_dimension_mean = st.number_input('fractal_dimension_mean', value=0.04)
radius_se = st.slider('radius_se', min_value=0.1, max_value=3.0, value=0.1, step=0.02)
smoothness_se = st.number_input('smoothness_se', value=0.001)
compactness_se = st.number_input('compactness_se', value=0.0002)
concave_points_se = st.slider('concave points_se', min_value=0.1, max_value=0.4, value=0.1, step=0.002)
symmetry_worst = st.slider('symmetry_worst', min_value=0.1, max_value=0.7, value=0.1, step=0.02)

datos = [[radius_mean, texture_mean, smoothness_mean, compactness_mean, symmetry_mean, fractal_dimension_mean, radius_se, smoothness_se, compactness_se, concave_points_se, symmetry_worst]]
data = pd.DataFrame(datos, columns=['radius_mean', 'texture_mean', 'smoothness_mean', 'compactness_mean', 'symmetry_mean', 'fractal_dimension_mean', 'radius_se', 'smoothness_se', 'compactness_se', 'concave_points_se', 'symmetry_worst']) #Dataframe con los mismos nombres de variables

#Se realiza la preparación
data_preparada=data.copy()
#Se adicionan las columnas faltantes
data_preparada=data_preparada.reindex(columns=variables,fill_value=0)
data_preparada.head()

#Normalización
data_preparada[['radius_mean', 'texture_mean', 'smoothness_mean', 'compactness_mean', 'symmetry_mean', 'fractal_dimension_mean', 'radius_se', 'smoothness_se', 'compactness_se', 'concave points_se', 'symmetry_worst']]= min_max_scaler.transform(data_preparada[['radius_mean', 'texture_mean', 'smoothness_mean', 'compactness_mean', 'symmetry_mean', 'fractal_dimension_mean', 'radius_se', 'smoothness_se', 'compactness_se', 'concave points_se', 'symmetry_worst']]) 
data_preparada.head()

#Hacemos la predicción con Red Neuronal
Y_fut = modelNN.predict(data_preparada)
data['Neural_Network']=Y_fut
data.head()

data.head()